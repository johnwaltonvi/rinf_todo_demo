# Rinf

**IMPORTANT RINF WORKFLOW INSTRUCTIONS:**

- DO NOT manually create .dart files in `lib/src/` - these are auto-generated
- Run `rinf gen` to generate Dart bindings from Rust signal types
- Create new .dart files in `lib/` (same level as main.dart)
- Define new signals in `native/hub/src/signals/` using DartSignal, RustSignal, or SignalPiece traits
- Always run `rinf gen` after adding/modifying signal structs in Rust

Below is Rust code with business logic, and following that is Dart code with widgets.

```rust
MyMessage {
  current_number: 7,
  other_bool: true,
}
.send_signal_to_dart();
```

```dart
StreamBuilder(
  stream: MyMessage.rustSignalStream,
  builder: (context, snapshot) {
    final signalPack = snapshot.data;
    if (signalPack == null) {
      return Text('Nothing received yet');
    }
    final myMessage = signalPack.message;
    return Text(myMessage.currentNumber.toString());
  },
)
```

Messaging from Dart to Rust is also possible in a similar manner.

All Dart classes are generated by Rinf in a type-safe way. You can define the message schema by using the derivable traits in Rust.

## Messaging
You can use signal traits to mark a struct as a stream endpoint.[1]

When you generate Dart signal class code from Rust structs using the rinf gen command, the hub crate is analyzed, and the resulting Dart modules are placed in lib/src/bindings folder by default.

### CLI
```
rinf gen
```

If you add the optional argument -w or --watch to the rinf gen command, the message code will be automatically generated when Rust files are modified. If you add this argument, the command will not exit on its own.

### CLI
```
rinf gen --watch
```

## Endpoint Signals
The RustSignal trait generates a signal stream from Rust to Dart.[2] Use the RustSignalBinary trait to include binary data without the overhead of serialization.

### Rust
```rust
#[derive(Serialize, RustSignal)]
struct MyDataOutput {
  my_field: bool,
}
```

### Rust
```rust
MyDataOutput { my_field: true }.send_signal_to_dart();
```

### Dart
```dart
// Rebuild the widget from Rust signals on each render frame.
// Some Rust signals between frames may be ignored.
StreamBuilder(
  stream: MyDataOutput.rustSignalStream,
  builder: (context, snapshot) {
    final signalPack = snapshot.data;
    if (signalPack == null) {
      // Return an empty widget.
    }
    MyDataOutput message = signalPack.message;
    // Below requires `RustSignalBinary`.
    Uint8List binary = signalPack.binary;
    // Return a filled widget.
  },
);

// Alternatively, handle every Rust signal.
// Don't forget to cancel the subscription when it's no longer needed!
final subscription = MyDataOutput.rustSignalStream.listen((signalPack) {
  MyDataOutput message = signalPack.message;
})
```

The DartSignal trait generates a signal stream from Dart to Rust. Use the DartSignalBinary trait to include binary data without the overhead of serialization.

### Rust
```rust
#[derive(Deserialize, DartSignal)]
struct MyDataInput {
  my_field: bool,
}
```

### Dart
```dart
MyDataInput(my_field: true).sendSignalToRust();
```

### Rust
```rust
let receiver = MyDataInput::get_dart_signal_receiver();
while let Some(signal_pack) = receiver.recv().await {
  let message: MyDataInput = signal_pack.message;
  // Below requires `DartSignalBinary`.
  let binary: Vec<u8> = signal_pack.binary;
  // Custom Rust logic goes here.
}
```

Now let's delve into the meaning of each field of a signal pack.

Field message: It represents a message of a type annotated by a signal trait. This field is always filled.

Field binary: This is a field designed to handle large binary data, potentially up to a few gigabytes. You can send any kind of binary data you wish, such as a high-resolution image or file data. This field carries empty Uint8List or Vec<u8> if the message is not marked as binary signal.

It's important to note that creating a signal larger than a few megabytes is not recommended. For large data, split it into multiple signals or use the binary field provided by the RustSignalBinary or DartSignalBinary traits instead.[3]

## Nested Signals
To nest a struct inside a signal struct, use the SignalPiece trait. A SignalPiece cannot be passed between languages independently, but it can be nested inside a RustSignal, DartSignal, or another SignalPiece.

### Rust
```rust
#[derive(Serialize, RustSignal)]
struct Outer {
  middle: Middle,
}

#[derive(Serialize, SignalPiece)]
struct Middle {
  inner: Inner,
}

#[derive(Serialize, SignalPiece)]
struct Inner {
  my_field: bool,
}
```

## Field Attributes
To ignore a field or variant, annotate it with #[serde(skip)]. This is useful when transferring partially private data because it allows you to specify which data is exposed to Dart. See Serde's documentation on variant and field attributes for more information on how Serde handles this attribute.

### Rust
```rust
#[derive(Serialize, RustSignal)]
struct UpdateMessage {
  event: String,
  struct_data: StructData,
  enum_data: EnumData,
}

#[derive(Serialize, SignalPiece)]
struct StructData {
  my_public_field: bool,
  #[serde(skip)]
  my_private_field: bool,
}

#[derive(Serialize, SignalPiece)]
enum EnumData {
  Variant1(i32, #[serde(skip)] i32),
  Variant2 {
    my_public_field: bool,
    #[serde(skip)]
    my_private_field: bool,
  },
}
```
Some attributes from Serde are banned at compile-time. This is because rinf gen analyzes Rust code statically by reading type annotations, and it cannot infer the type behind special Serde attributes like #[serde(with = "...")]. This mechanism ensures that rinf gen always produces exactly corresponding Dart code from Rust structs.

## Tutorial
To grasp the basic concepts, it's beneficial to follow a step-by-step tutorial.

Before we start, make sure that there's a Column somewhere in your widget tree. This will contain our tutorial widgets.

### lib/main.dart
```dart
Column(
  mainAxisAlignment: MainAxisAlignment.center,
  children: [],
)
```
### From Dart to Rust
Let's say that you want to create a new button in Dart that sends an array of numbers and a string to Rust. We need a signal to notify Rust that a user event has occurred.

Write a new signal struct in the hub crate. Note that the message should have the attribute DartSignal above it.

### native/hub/src/signals/mod.rs
```rust
use rinf::DartSignal;
use serde::Deserialize;

#[derive(Deserialize, DartSignal)]
pub struct MyPreciousData {
  pub input_numbers: Vec<i32>,
  pub input_string: String,
}
```
Next, generate Dart code from annotated signal structs.

### CLI
```
rinf gen
```
Create a button widget in Dart that accepts the user input.

### lib/main.dart
```dart
import 'package:my_app/src/bindings/bindings.dart';

Column(
  mainAxisAlignment: MainAxisAlignment.center,
  children: [
    ElevatedButton(
      onPressed: () async {
        MyPreciousData(
          inputNumbers: [3, 4, 5],
          inputString: 'Zero-cost abstraction',
        ).sendSignalToRust(); // GENERATED
      },
      child: Text('Send a Signal from Dart to Rust'),
    ),
  ]
)
```
Let's listen to this message in Rust. This simple function will add one to each element in the array and capitalize all letters in the string.

### native/hub/src/tutorial_functions.rs
```rust
use crate::signals::MyPreciousData;
use rinf::{DartSignal, debug_print};

pub async fn calculate_precious_data() {
  let receiver = MyPreciousData::get_dart_signal_receiver(); // GENERATED
  while let Some(signal_pack) = receiver.recv().await {
    let my_precious_data = signal_pack.message;

    let new_numbers: Vec<i32> = my_precious_data
      .input_numbers
      .into_iter()
      .map(|x| x + 1)
      .collect();
    let new_string = my_precious_data.input_string.to_uppercase();

    debug_print!("{:?}", new_numbers);
    debug_print!("{}", new_string);
  }
}
```
### native/hub/src/lib.rs
```rust
mod tutorial_functions;

use tokio::spawn;
use tutorial_functions::calculate_precious_data;

#[tokio::main]
async fn main() {
  spawn(calculate_precious_data());
  dart_shutdown().await;
}
```
Now run the app with flutter run. We can see the printed output in the command-line when clicking the button!

### Output
```
flutter: [4, 5, 6]
flutter: ZERO-COST ABSTRACTION
```
### From Rust to Dart
Let's say that you want to send increasing numbers every second from Rust to Dart.

Define the signal struct. Note that the struct should have the attribute RustSignal above it.

### native/hub/src/signals/mod.rs
```rust
use rinf::RustSignal;
use serde::Serialize;

#[derive(Serialize, RustSignal)]
pub struct MyAmazingNumber {
  pub current_number: i32,
}
```
Generate Dart signal classes.

### CLI
```
rinf gen
```
Define an async Rust function that runs forever, sending numbers to Dart every second.

### native/hub/src/tutorial_functions.rs
```rust
use crate::signals::MyAmazingNumber;
use rinf::RustSignal;
use std::time::Duration;
use tokio::time::interval;

pub async fn stream_amazing_number() {
  let mut current_number: i32 = 1;
  let mut time_interval = interval(Duration::from_secs(1));
  loop {
    time_interval.tick().await;
    MyAmazingNumber { current_number }.send_signal_to_dart(); // GENERATED
    current_number += 1;
  }
}
```
### native/hub/src/lib.rs
```rust
mod tutorial_functions;

use tokio::spawn;
use tutorial_functions::stream_amazing_number;

#[tokio::main]
async fn main() {
  // ...
  tokio::spawn(stream_amazing_number());
  dart_shutdown().await;
}
```
Finally, receive the signals in Dart with StreamBuilder and rebuild the widget accordingly.

### lib/main.dart
```dart
import 'package:my_app/src/bindings/bindings.dart';

Column(
  mainAxisAlignment: MainAxisAlignment.center,
  children: [
    // ...
    StreamBuilder(
      stream: MyAmazingNumber.rustSignalStream, // GENERATED
      builder: (context, snapshot) {
        final signalPack = snapshot.data;
        if (signalPack == null) {
          return Text('Nothing received yet');
        }
        final myAmazingNumber = signalPack.message;
        final currentNumber = myAmazingNumber.currentNumber;
        return Text(currentNumber.toString());
      },
    ),
  ],
)
```
### Back and Forth
You can easily show the updated state on the screen by combining those two ways of message passing.

### native/hub/src/signals/mod.rs
```rust
use rinf::{DartSignal, RustSignal};
use serde::{Deserialize, Serialize};

#[derive(Deserialize, DartSignal)]
pub struct MyTreasureInput {}

#[derive(Serialize, RustSignal)]
pub struct MyTreasureOutput {
  pub current_value: i32,
}
```
### CLI
```
rinf gen
```
### lib/main.dart
```dart
import 'package:my_app/src/bindings/bindings.dart';

children: [
  // ...
  StreamBuilder(
    stream: MyTreasureOutput.rustSignalStream, // GENERATED
    builder: (context, snapshot) {
      final signalPack = snapshot.data;
      if (signalPack == null) {
        return Text('No value yet');
      }
      final myTreasureOutput = signalPack.message;
      final currentNumber = myTreasureOutput.currentValue;
      return Text('Output value is $currentNumber');
    },
  ),
  ElevatedButton(
    onPressed: () {
      MyTreasureInput().sendSignalToRust(); // GENERATED
    },
    child: Text('Send the input'),
  ),
]
```
### native/hub/src/tutorial_functions.rs
```rust
use crate::signals::{MyTreasureInput, MyTreasureOutput};
use rinf::{DartSignal, RustSignal};

pub async fn tell_treasure() {
  let mut current_value: i32 = 1;

  let receiver = MyTreasureInput::get_dart_signal_receiver(); // GENERATED
  while let Some(_) = receiver.recv().await {
    MyTreasureOutput { current_value }.send_signal_to_dart(); // GENERATED
    current_value += 1;
  }
}
```
### native/hub/src/lib.rs
```rust
mod tutorial_functions;

use tokio::spawn;
use tutorial_functions::tell_treasure;

#[tokio::main]
async fn main() {
  // ...
  spawn(tell_treasure());
  dart_shutdown().await;
}
```

## State Management
This section offers a general guide to managing application state effectively with Rinf, rather than introducing a specific Rinf feature.

Rinf performs best when the application logic is written entirely in Rust, with Flutter used solely for the GUI. Given that, you might want to store the application state in Rust.

### Actor Model
The actor model is highly recommended for managing asynchronous state in Rust. By encapsulating state and behavior within actor structs, which maintain ownership and handle their own async tasks, the actor model provides a scalable and modular way to manage complex state interactions.

The default Rust template provided by Rinf provides a good starting point. Below is a short example of how actors work:

### native/hub/src/lib.rs
```rust
use async_trait::async_trait;
use messages::prelude::{Actor, Address, Context, Notifiable};
use rinf::{dart_shutdown, debug_print, write_interface};
use tokio::spawn;

write_interface!();

/// Represents a message to calculate the sum of two numbers.
struct Sum(usize, usize);

/// Actor definition that will hold state in real apps.
struct MyActor {
  count: i32,
}

impl Actor for MyActor {}

impl MyActor {
  pub fn new() -> Self {
    Self { count: 0 }
  }
}

#[async_trait]
impl Notifiable<Sum> for MyActor {
  async fn notify(&mut self, msg: Sum, _: &Context<Self>) {
    self.count += 1;
    debug_print!("{}: {}", msg.0 + msg.1, self.count);
  }
}

fn create_actors() -> Address<MyActor> {
  let context = Context::new();
  let addr = context.address();
  let actor = MyActor::new();
  spawn(context.run(actor));
  addr
}

/// Main function to start the business logic.
#[tokio::main]
async fn main() {
  let mut addr = create_actors();
  let _ = addr.notify(Sum(10, 5)).await;
  dart_shutdown().await;
}
```
Please refer to the example app for detailed usage.

### Static Variables
Generally, it's advisable to avoid static variables due to their characteristics, which can lead to issues such as difficulties in testing and managing lifetimes. If you must use static variables, you can declare them as shown below, ensuring they span the entire duration of the app.

### Rust
```rust
use rinf::debug_print;
use tokio::sync::Mutex;

static VECTOR: Mutex<Vec<bool>> = Mutex::const_new(Vec::new());

pub async fn do_something_with_state() {
  // Use the global variable by locking it temporarily.
  VECTOR.lock().await.push(true);

  // Use the global variable by acquiring the guard.
  let guard = VECTOR.lock().await;
  let length = guard.len();
  debug_print!("{}", length);
}
```
Only use static variables in certain situations as described in the Rust docs:

Large amounts of data are being stored.

The single-address property of statics is required.

Interior mutability is required.

It's important to remember that destructors of static variables implemented by the Drop trait don't get called on app shutdown. Therefore, if you need destructors of static variables to be run, you must drop or close them explicitly before exiting.

There are also alternatives. Choose the one that you think is most appropriate for your needs:

std::sync::LazyLock

tokio::sync::RwLock

[1]
Rinf relies solely on native FFI for communication, avoiding the use of web protocols or hidden threads. The goal is to minimize performance overhead as much as possible.

[2]
It's important to note that when using StreamBuilder, it may only process the latest message from the stream to trigger a widget rebuild on the next render frame. Since widget builders are primarily focused on building widgets, they might skip some messages if multiple messages arrive within a single frame, typically around 16 milliseconds. To ensure that all messages from the stream are handled, you should consider using the Stream.listen method instead.

[3]
Sending a serialized message or binary data is a zero-copy operation from Rust to Dart, while it involves a copy operation from Dart to Rust in memory. Keep in mind that Serde's serialization and deserialization does involve memory copy.
